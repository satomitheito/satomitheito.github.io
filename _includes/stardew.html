<!-- Sprite Movement Section -->
<div class="sprite-section">
    <canvas id="gameCanvas" width="1290" height="600"></canvas>
</div>
  
<script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    //Load the background image
    const background = new Image();
    background.src = "/assets/img/stardewmap.png"
    // Load the sprite
    const sprite = new Image();
    sprite.src = "/assets/img/White Chicken.png"; // Adjust path to your sprite image

    // Define sprite properties
    const frameWidth = 16; // Width of one frame
    const frameHeight = 15; // Height of one frame
    let currentFrame = 0; // Current frame of the animation
    let frameDelay = 10; // Frames to wait before moving to the next animation frame
    let frameCounter = 0;
    const scale = 2; // Scaling factor for the sprite

    // Character object
    const character = {
        x: canvas.width / 2 - frameWidth / 2, // Center the character on the canvas
        y: canvas.height / 2 - frameHeight / 2,
        speed: 5,
        direction: 0, // Default direction is "Down" (row 0)
    };

    // Keys object for tracking pressed keys
    const keys = {};
    window.addEventListener("keydown", (e) => (keys[e.key] = true));
    window.addEventListener("keyup", (e) => (keys[e.key] = false));

    // disable scrolling
    window.addEventListener("keydown", function(e) {
        if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
            e.preventDefault();
        }
    }, false);

    // Mapping directions to the correct row in the sprite sheet
    const directionMapping = {
        "ArrowDown": 0,  // Down corresponds to row 0
        "ArrowLeft": 3,  // Left corresponds to row 1
        "ArrowRight": 1, // Right corresponds to row 2
        "ArrowUp": 2,    // Up corresponds to row 3
    };

    // Update character movement
    function update() {
        if (keys["ArrowUp"]) {
            character.y -= character.speed;
            character.direction = directionMapping["ArrowUp"];
        }
        if (keys["ArrowDown"]) {
            character.y += character.speed;
            character.direction = directionMapping["ArrowDown"];
        }
        if (keys["ArrowLeft"]) {
            character.x -= character.speed;
            character.direction = directionMapping["ArrowLeft"];
        }
        if (keys["ArrowRight"]) {
            character.x += character.speed;
            character.direction = directionMapping["ArrowRight"];
        }

        // Boundary checks
        if (character.x < 0) character.x = 0;
        if (character.y < 0) character.y = 0;
        if (character.x + frameWidth * scale > canvas.width)
            character.x = canvas.width - frameWidth * scale;
        if (character.y + frameHeight * scale > canvas.height)
            character.y = canvas.height - frameHeight * scale;

        // Update animation frame
        frameCounter++;
        if (frameCounter >= frameDelay) {
            frameCounter = 0;
            currentFrame = (currentFrame + 1) % 4; // Assuming 4 frames per direction
        }
    }

    // Draw the character
    function draw() {
        // Clear the canvas to prevent flickering
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Calculate the source position on the sprite sheet
        const sourceX = currentFrame * frameWidth;
        const sourceY = character.direction * frameHeight;

        // Draw the current frame of the sprite, scaling it
        ctx.drawImage(
            sprite,
            sourceX,
            sourceY,
            frameWidth,
            frameHeight,
            character.x,
            character.y,
            frameWidth * scale,
            frameHeight * scale
        );
    }

    // Game loop
    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    // Start the game loop when the sprite loads
    sprite.onload = () => {
        gameLoop();
    };
</script>