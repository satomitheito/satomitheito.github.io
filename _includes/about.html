<div class="user-details">
  <img src="/assets/img/aboutme.png" alt="About Me" class="featured-image" />
</div>
<div class="user-projects">
  <div class="contents-right">
    <div class="images-left">
      <img alt="About Me Image" src="{{ "/assets/img/prof.png" | prepend: site.baseurl }}" width = "350"/>
    </div>
    <p>
      Hello! I'm Satomi Ito, an aspiring data scientist with a passion for turning complex problems into meaningful solutions. With a background in cognitive science, I have a multidisciplinary approach that allows me to connect technical skills with human-centered thinking, making my work both impactful and innovative.
    </p>
    <p>
      I have hands-on experience with data visualization, natural language processing, and predictive modeling. Tools like Python, R, and SQL are my go-to, and I am always excited to explore new technologies like deep learning frameworks and data engineering pipelines. Beyond the technical side, I love collaborating, presenting, and adapting to challenges with a curious and proactive attitude.
    </p>
    <p>
      In my free time, you will find me climbing walls or diving into DIY projects.
    </p>
  </div>
</div>


<div class="image-grid">
  <div class="grid-item">
    <img src="/assets/img/ski.jpg" alt="Image 1" />
    <div class="hover-text">Learned how to ski at Mont-Tremblant</div>
  </div>
  <div class="grid-item">
    <img src="/assets/img/cat.JPG" alt="Image 2" />
    <div class="hover-text">Radahn's first snow!</div>
  </div>
  <div class="grid-item">
    <img src="/assets/img/cssa.jpg" alt="Image 3" />
    <div class="hover-text">Hosted Cognitive Science Student Association's Workshop</div>
  </div>
</div>



<!-- Sprite Movement Section -->
<div class="sprite-section">
  <h2>Control the Cat Sprite!</h2>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
</div>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  // Load the sprite
  const sprite = new Image();
  sprite.src = "/assets/files/cat5.png"; // Adjust path to your sprite image

  // Define sprite properties
  const frameWidth = 32; // Width of one frame
  const frameHeight = 32; // Height of one frame
  let currentFrame = 0; // Current frame of the animation
  let frameDelay = 10; // Frames to wait before moving to the next animation frame
  let frameCounter = 0;
  const scale = 2; // Scaling factor for the sprite

  // Character object
  const character = {
    x: canvas.width / 2 - frameWidth / 2, // Center the character on the canvas
    y: canvas.height / 2 - frameHeight / 2,
    speed: 5,
    direction: 0, // Default direction is "Down" (row 0)
  };

  // Keys object for tracking pressed keys
  const keys = {};
  window.addEventListener("keydown", (e) => (keys[e.key] = true));
  window.addEventListener("keyup", (e) => (keys[e.key] = false));

  // disable scrolling
  window.addEventListener("keydown", function(e) {
    if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
      e.preventDefault();
    }
  }, false);

  // Mapping directions to the correct row in the sprite sheet
  const directionMapping = {
    "ArrowDown": 0,  // Down corresponds to row 0
    "ArrowLeft": 3,  // Left corresponds to row 1
    "ArrowRight": 1, // Right corresponds to row 2
    "ArrowUp": 2,    // Up corresponds to row 3
  };

  // Update character movement
  function update() {
    if (keys["ArrowUp"]) {
      character.y -= character.speed;
      character.direction = directionMapping["ArrowUp"];
    }
    if (keys["ArrowDown"]) {
      character.y += character.speed;
      character.direction = directionMapping["ArrowDown"];
    }
    if (keys["ArrowLeft"]) {
      character.x -= character.speed;
      character.direction = directionMapping["ArrowLeft"];
    }
    if (keys["ArrowRight"]) {
      character.x += character.speed;
      character.direction = directionMapping["ArrowRight"];
    }

    // Boundary checks
    if (character.x < 0) character.x = 0;
    if (character.y < 0) character.y = 0;
    if (character.x + frameWidth * scale > canvas.width)
      character.x = canvas.width - frameWidth * scale;
    if (character.y + frameHeight * scale > canvas.height)
      character.y = canvas.height - frameHeight * scale;

    // Update animation frame
    frameCounter++;
    if (frameCounter >= frameDelay) {
      frameCounter = 0;
      currentFrame = (currentFrame + 1) % 4; // Assuming 4 frames per direction
    }
  }

  // Draw the character
  function draw() {
    // Clear the canvas to prevent flickering
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Calculate the source position on the sprite sheet
    const sourceX = currentFrame * frameWidth;
    const sourceY = character.direction * frameHeight;

    // Draw the current frame of the sprite, scaling it
    ctx.drawImage(
      sprite,
      sourceX,
      sourceY,
      frameWidth,
      frameHeight,
      character.x,
      character.y,
      frameWidth * scale,
      frameHeight * scale
    );
  }

  // Game loop
  function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }

  // Start the game loop when the sprite loads
  sprite.onload = () => {
    gameLoop();
  };
</script>